{\rtf1\ansi\ansicpg1252\deff0{\fonttbl{\f0\fswiss\fcharset0 Calibri;}{\f1\fnil\fcharset2 Symbol;}{\f2\fswiss\fprq1\fcharset204 Consolas;}{\f3\fswiss\fprq1\fcharset0 Consolas;}{\f4\fswiss\fcharset204 Calibri;}}
{\colortbl ;\red0\green0\blue255;\red0\green0\blue0;\red208\green208\blue208;}
{\*\generator Msftedit 5.41.21.2510;}\viewkind4\uc1\pard\nowidctlpar\sl276\slmult1\qc\lang9\ul\b\f0\fs52 RayFire Rigid\lang1033\ulnone\b0\fs24\par
\pard\nowidctlpar\sl276\slmult1\par
\lang9\fs22 It's main purpose is \b Advanced Physics Control\b0  and \b Runtime Demolitions\b0 . Using Rigid component you can demolish 3d objects into thousands fragments and every fragment can be demolished further deeper and deeper.\lang1033\fs24\par
\par
\lang9\b\fs22 Initialization\lang1033\b0 : Defines when object will be initialized. Initialization adds all necessary components to object, setup them accordingly to properties and start necessary coroutines.\fs24\par
\b\fs32{\field{\*\fldinst{HYPERLINK "https://youtu.be/-wW9OfnhIh0"}}{\fldrslt{\ul\cf1 https://youtu.be/-wW9OfnhIh0}}}\b0\f0\fs24\par
\par
\pard\nowidctlpar\li720\sl276\slmult1\tx720\f1\'b7\tab\b\f0\fs22 By Method\b0 : Object will be initialized by \b\i Initialize()\b0  \i0 method. This is default initialization type. In this way you can add Rigid component to objects in your code and they will not be initialized unless you will Initialize them as well. Object with \b ByMethod\b0  type can be initialized in Editor using Initialize button on top of Rigid component.\fs24\par
\f1\'b7\tab\b\f0\fs22 At Start\b0 : Object will be initialized at Start.\fs24\par
\pard\nowidctlpar\li360\sl276\slmult1\par
\pard\nowidctlpar\sl276\slmult1\lang9\fs22 Object can be initialized using method:\lang1033\fs24\par
\cf1\lang1049\f2\fs19 public\cf2  \cf1 void\cf2  \lang1033\f3 Initialize\lang1049\f2 ()\cf0\lang1033\f0\fs24\par
\lang9\fs28\tab\lang1033\fs24\par
\lang9\b\fs48\tab Main\lang1033\b0\fs24\par
\par
\lang9\b\fs22 Simulation Type\lang1033\b0 : Defines behavior of object during simulation.\fs24\par
\b\fs32{\field{\*\fldinst{HYPERLINK "https://youtu.be/KZ8h9F45lkM"}}{\fldrslt{\ul\cf1 https://youtu.be/KZ8h9F45lkM}}}\b0\f0\fs24\par
\par
\pard\nowidctlpar\li720\sl276\slmult1\tx720\f1\'b7\tab\b\f0\fs22 Dynamic\b0 : Object will be affected by gravity, will start fall down and it will be possible to affect on it by other simulated objects. \fs24\par
\f1\'b7\tab\b\f0\fs22 Sleeping\b0 : Object will freeze in air until first collision with any other object, then it will start behave as Dynamic object.\fs24\par
\f1\'b7\tab\b\f0\fs22 Inactive\b0 : Object will freeze in air and will not be affected by gravity, it can be affected by other simulated objects but it will not start fall down until it will be activated. After activation object will start behave like Dynamic object.\fs24\par
\f1\'b7\tab\b\f0\fs22 Kinematic\b0 : Object will use it's animation to affect to other objects but it will not be affected anyhow by any other object. Can use actual mesh as collider.\fs24\par
\f1\'b7\tab\b\f0\fs22 Static\b0 : Object will not be moved from it's position, it will interact with Dynamic objects but it will not be affected anyhow by any other object. Can use actual mesh as collider.\fs24\par
\pard\nowidctlpar\sl276\slmult1\par
\pard\nowidctlpar\sl276\slmult1\qc\lang9\b\fs22 ***\lang1033\b0\fs24\par
\pard\nowidctlpar\sl276\slmult1\par
\lang9\b\fs22 Object Type\lang1033\b0 : Rigid component can simulate single object using it's mesh for simulation, but also it can simulate multiple objects as one concave object using all children meshes.\fs24\par
\lang9\b\fs32{\field{\*\fldinst{HYPERLINK "https://youtu.be/fbVG1Y0RoBY"}}{\fldrslt{\ul\cf1 https://youtu.be/fbVG1Y0RoBY}}}\lang1033\b0\f0\fs24\par
\par
\pard\nowidctlpar\li720\sl276\slmult1\tx720\f1\'b7\tab\b\f0\fs22 Mesh\b0 : Simulate object using it's Meshfilter's mesh in Mesh Collider.\fs24\par
\f1\'b7\tab\b\f0\fs22 Mesh Root\b0 : Should be added to empty root with children with meshes. Add same Rigid component to all children and simulate them as \b Mesh \b0 type. Root itself is not going to be simulated. Using this type you don't need to select every children to add Rigid components or to edit them later, you only need to edit all properties for Root.\fs24\par
\f1\'b7\tab\b\f0\fs22 Skinned Mesh\b0 : Demolishes Skinned mesh object.\fs24\par
\f1\'b7\tab\b\f0\fs22 Nested Cluster\b0 : Simulated object using all it's children Meshfilter's meshes as one solid concave object. In this case root will get Mesh Collider for every child with it's mesh. To Create such object you need to add Rigid component to root which has all objects which you want to simulate as solid object as it's children. In case of demolition Cluster will detach every child and start simulate them on their own. If child is also just a root for other children with meshes after demolition it will be considered as Nested Cluster as well. In this way you can demolish object in your own way.\fs24\par
\f1\'b7\tab\b\f0\fs22 Connected Cluster\b0 : Simulated object using all it's children Meshfilter's meshes as one solid concave object like Nested Cluster. It uses only children from first layer, nesting is not allowed.  During demolition it will detach fragments at contact point while the rest of the fragments will stay as solid cluster. At every demolition cluster checks itself for connectivity and if it detects that some groups of fragments are not connected together anymore they will start simulate as separate Connected Clusters.\fs24\par
\pard\nowidctlpar\sl276\slmult1\par
\pard\nowidctlpar\sl276\slmult1\qc\lang9\b\fs22 ***\lang1033\b0\fs24\par
\pard\nowidctlpar\li360\sl276\slmult1\par
\pard\nowidctlpar\sl276\slmult1\lang9\b\fs22 Demolition Type\b0 : \lang1033 Define when and how object will be demolished during Play mode. \fs24\par
\b\fs32{\field{\*\fldinst{HYPERLINK "https://youtu.be/_aO08dcqBOQ"}}{\fldrslt{\ul\cf1 https://youtu.be/_aO08dcqBOQ}}}\b0\f0\fs24\par
\par
\pard\nowidctlpar\li720\sl276\slmult1\tx720\f1\'b7\tab\b\f0\fs22 None\b0 : Object will not be demolished.\fs24\par
\f1\'b7\tab\b\f0\fs22 Runtime\b0 : Object will be demolished in Runtime. Fragments will be created at collision contact moment. It is better to use this type for low poly objects with low Fragments \b Amount \b0 value. Slowest speed among other types.\fs24\par
\f1\'b7\tab\b\f0\fs22 Awake Precache\b0 : Object will precached all fragments mesh data in Awake and store all mesh data info in Rigid component. At collision contact gameobjects with all necessary components will be created and mesh will be assigned. \fs24\par
\f1\'b7\tab\b\f0\fs22 Awake Prefragment\b0 : Object will be prefragmented in Awake. All fragments will be disabled and waiting for demolition. \fs24\par
\f1\'b7\tab\b\f0\fs22 Reference Demolition\b0 : Allows to swap demolished object to predefined reference and demolish instance of this reference instead. Reference object could be FBX asset, prefab or other scene object.\fs24\par
\pard\nowidctlpar\sl276\slmult1\qc\par
\pard\nowidctlpar\sl276\slmult1\lang9\b\fs48\tab Simulation\lang1033\b0\fs24\par
\par
\lang9\fs44\tab Physics\lang1033\fs24\par
\lang9\b\fs32{\field{\*\fldinst{HYPERLINK "https://youtu.be/MxMaPZLpLto"}}{\fldrslt{\ul\cf1 https://youtu.be/MxMaPZLpLto}}}\lang1033\b0\f0\fs24\par
\par
\lang9\b\fs28\tab Physic Material\lang1033\b0\fs24\par
\par
\b\fs22 Material Type\b0 : Material preset with predefined density, friction, elasticity and solidity. Can be edited in Rayfire Man component.\fs24\par
\par
\b\fs22 Material\b0 : Allows to define define own \b Physic Material.\b0  Keep in mind that it still will use define \b Material Type\b0  for \b Solidity \b0 and \b Mass\b0 .\fs24\par
\par
\lang9\b\fs28\tab Mass\lang1033\b0\fs24\par
\par
\b\fs22 Mass By\b0 : Allows to choose the way Mass will be applied to RigidBody component.\fs24\par
\pard\nowidctlpar\li720\sl276\slmult1\tx720\f1\'b7\tab\lang9\b\f0\fs22 Material Density\b0 : \lang1033 Object will get mass accordingly to defined \b Material Type \b0 and mesh volume.\fs24\par
\f1\'b7\tab\lang9\b\f0\fs22 Mass Property\b0 : \lang1033 Object will get mass by Mass property\fs24\par
\pard\nowidctlpar\sl276\slmult1\b\fs22 Mass\b0 : RigidBody component will get this value if \b Mass By\b0  set to \lang9\b Mass Property.\lang1033\b0\fs24\par
\par
\lang9\b\fs28\tab Other\lang1033\b0\fs24\par
\par
\b\fs22 Collider Type\b0 : Allows to choose automatic collider type for object if object has no custom collider applied.\fs24\par
\pard\nowidctlpar\li720\sl276\slmult1\tx720\f1\'b7\tab\lang9\b\f0\fs22 Mesh\b0 : \lang1033 Object will get Mesh Collider.\fs24\par
\f1\'b7\tab\lang9\b\f0\fs22 Sphere\b0 : \lang1033 Object will Sphere Collider.\fs24\par
\f1\'b7\tab\lang9\b\f0\fs22 Box\b0 : \lang1033 Object will get Box Collider.\fs24\par
\f1\'b7\tab\lang9\b\f0\fs22 None\b0 : \lang1033 Object will not get automatic collider.\fs24\par
\pard\nowidctlpar\li360\sl276\slmult1\par
\pard\nowidctlpar\sl276\slmult1\b\fs22 Use Gravity\b0 : Object will be affectd by Gravity force. \fs24\par
\par
\lang9\b\fs28\tab Fragments\lang1033\b0\fs24\par
\b\fs22 Dampening\b0 : Decrease velocity of demolished fragments.\fs24\par
\pard\nowidctlpar\li360\sl276\slmult1\par
\pard\nowidctlpar\sl276\slmult1\lang9\i\fs44\tab Activation\lang1033\i0\fs24\par
\lang9\b\fs32{\field{\*\fldinst{HYPERLINK "https://youtu.be/t8JbxKyP91Y"}}{\fldrslt{\ul\cf1 https://youtu.be/t8JbxKyP91Y}}}\lang1033\b0\f0\fs24\par
\par
\lang9\fs22 Inactive object can be activated using public method:\lang1033\fs24\par
\cf1\lang1049\f2\fs19 public\cf2  \cf1 void\cf2  Activate()\cf0\lang1033\f0\fs24\par
\par
\lang9\b\fs22 By Velocity\b0 : \lang1033 Inactive object will be activated when it's velocity will be higher than \b By Velocity \b0 value when it was pushed by other dynamic objects. Turned Off when set to 0.\fs24\par
\par
\lang9\b\fs22 By Offset\b0 : \lang1033 Inactive object will be activated if will be pushed from it's original position farther than \b By Offset \b0 value. Turned Off when set to 0.\fs24\par
\par
\lang9\b\fs22 By Damage\b0 : \lang1033 Inactive object will be activated if it's Current Damage will be higher than \lang9\b By Damage\lang1033\b0  value. Turned Off when set to 0.\fs24\par
\par
\lang9\b\fs22 By Activator\b0 : \lang1033 Inactive object will be activated by overlapping with object with \b RayFire Activator \b0 component.\fs24\par
\par
\lang9\b\fs22 By Impact\b0 : \lang1033 Inactive object will be activated when it will be shot by \b RayFire Gun \b0 component.\fs24\par
\par
\lang9\b\fs22 By Connectivity\b0 : \lang1033 Inactive object will be activated if it won't be able to reach any Inactive object with Unyielding property On through other Inactive objects. \b RayFire Connectivity \b0 components has to be used to establish connectivity between Inactive objects and activate them if they loose connection with other Inactive objects.\fs24\par
\par
\lang9\b\fs28\tab Connectivity\lang1033\b0\fs24\par
\par
\b\fs22 Unyielding\b0 : Allows to define Inactive/Kinematic object as Unyielding to check fo connection with  other Inactive/Kinematic objects with enabled By Connectivity activation type.\fs24\par
\par
\b\fs22 Activatable\b0 : Unyielding object can not be activate by default. When On allows to activate Unyielding objects as well.\fs24\par
\lang9\b\fs28\tab\lang1033\b0\fs24\par
\lang9\b\fs48\tab Demolition\lang1033\b0\fs24\par
\fs22 Demolition can be initiated using method:\fs24\par
\cf1\lang1049\f2\fs19 public\cf2  \cf1 void\cf2  DemolishObject()\cf0\lang1033\f0\fs24\par
\par
\fs22 Slicing by planes can be initiated by method:\fs24\par
\pard\box\brdrs\brdrw0\brdrcf2 \nowidctlpar\sl276\slmult1\cf1\lang1049\f2\fs19 public\cf2  \cf1 void\cf2  \lang1033\f3 AddSlicePlane\lang1049\f2 (\lang1033\f3 V\cf0\lang1049\f2\fs18 ector3[] slicePlane\cf2\fs19 )\cf0\lang1033\f0\fs24\par
\cf2\f3\fs19 V\cf0\lang1049\f2\fs18 ector3[] slicePlane\lang1033\f3  \f0\fs22 is array with slicing planes info: \fs24\par
\pard\nowidctlpar\sl276\slmult1\fs22 (plane position, plane normal, plane position, plane normal, etc...)\fs24\par
\par
\lang9\i\fs44\tab Limitations\lang1033\i0\fs24\par
\lang9\b\fs32{\field{\*\fldinst{HYPERLINK "https://youtu.be/ITYShtaF5cQ"}}{\fldrslt{\ul\cf1 https://youtu.be/ITYShtaF5cQ}}}\lang1033\b0\f0\fs24\par
\par
\lang9\b\fs22 Solidity\b0 : Local \lang1033 Object solidity multiplier for object. Low Solidity makes object more fragile. Keep in mind that every \b Material Type \b0 in \b Physics \b0 group also has it's own Solidity. Set to 0 if you want object to be demolished at first contact.\fs24\par
\par
\lang9\b\fs22 Depth\b0 : \lang1033 Defines how deep object can be demolished. Depth is limitless if set to 0.\fs24\par
\i\fs22\tab Example\i0 : \lang9\b Max Depth \lang1033\b0 set to 1, it means that object can be demolished one time and \tab new fragments (Depth level 1 fragments) will not be possible to demolish anymore. \fs24\par
\fs22\tab If \lang9\b Max Depth \lang1033\b0 set to 2, it means that object can be demolished one time and new \tab fragments (Depth level 1 fragments) will possible to demolish one time, but new \tab fragments (Depth level 2 fragments) will not be possible to demolish anymore. Etc\fs24\par
\par
\lang9\b\fs22 Time\b0 : Safe time. Measures in seconds and a\lang1033 llows to prevent fragments from being demolished right after they were just initialized.\fs24\par
\i\fs22\tab Example\i0 : \lang9\b Time \lang1033\b0 set to 3 seconds, it means that object can be demolished and \tab new \tab fragments will not be demolished for sure during next 3 seconds.\fs24\par
\par
\lang9\b\fs22 Size\b0 : P\lang1033 revent objects with bounding box size less than defined value to be demolished. Measures in units.\fs24\par
\par
\lang9\b\fs22 Visible\b0 : Prevent object from being demolished if they are not visible by main camera.\lang1033 .\fs24\par
\par
\lang9\b\fs22 Slice by Blade\b0 : \lang1033 Allows object to be sliced by object with \b RayFire Blade \b0 component.\fs24\par
\par
\lang9\i\fs44\tab Mesh Demolition\lang1033\i0\fs24\par
\fs28\tab\fs24\par
\fs28\tab\b Fragments\b0\fs24\par
\par
\lang9\b\fs32{\field{\*\fldinst{HYPERLINK "https://youtu.be/TpTHstzzvRU"}}{\fldrslt{\ul\cf1 https://youtu.be/TpTHstzzvRU}}}\lang1033\b0\f0\fs24\par
\par
\lang9\b\fs22 Amount\b0 : \lang1033 Defines amount of new fragments after demolition.\fs24\par
\par
\lang9\b\fs22 Variation\b0 : \lang1033 Defines additional amount variation for object in percents. Final amount always will be higher than \b Amount \b0 value.\fs24\par
\i\fs22\tab Example\i0 : Amount set to 50, Variation set to 10 %. Final amount will be randomly picked \tab in range from 50 to 55. \fs24\par
\par
\lang9\b\fs22 Depth Fade\b0 : Amount m\lang1033 ultiplier for next Depth level. Allows to decrease fragments amount of every next demolition level.\fs24\par
\i\fs22\tab Example\i0 : \b Amount \b0 set to 100. \b Depth Fade \b0 set to 0.5. Object demolishes to 100 \tab fragments. For every fragment it's \b Amount \b0 for next demolition will be set to 50 (100 * \tab 0.5). Let's say some fragment demolishes to 50 fragments. For every fragment among \tab these 50 fragments it's \b Amount \b0 for next demolition will be set to 25 (50 * 0.5). \fs24\par
\par
\lang9\b\fs22 Contact Bias\b0 : Higher value a\lang1033 llows to create more tiny fragments closer to collision contact point and bigger fragments far from it. This is the property which makes player understand that Runtime demolition happened right now and nothing was prefragmented before.\fs24\par
\par
\lang9\b\fs22 Seed\b0 : \lang1033 Defines Seed for fragmentation algorithm. Same Seed will produce same fragments for same object every time.\fs24\par
\par
\lang9\b\fs22 Use Shatter\b0 : \lang1033 Allows to use RayFire Shatter properties for fragmentation. Works only if object has RayFire Shatter component. This is the only way to create other Fragmentation types in runtime because default demolition fragmentation type produce only regular Voronoi fragments.\fs24\par
\par
\b\fs28\tab Advanced\b0\fs24\par
\par
\b\fs22 Mesh Input\b0 : Allows to choose when demolished mesh should be processed for fragmentation. Processing takes about 10% - 15% of total fragmentation time. \fs24\par
\pard\nowidctlpar\li720\sl276\slmult1\tx720\f1\'b7\tab\lang9\b\f0\fs22 At Start\b0 : \lang1033 Mesh will be processed at Start.\fs24\par
\f1\'b7\tab\lang9\b\f0\fs22 At Initialization\b0 : \lang1033 Mesh will be processed at Initialization.\fs24\par
\f1\'b7\tab\lang9\b\f0\fs22 At Demolition\b0 : \lang1033 Mesh will be processed at Demolition.\fs24\par
\pard\nowidctlpar\sl276\slmult1\par
\lang9\i\fs36\tab Properties\lang1033\i0\fs24\par
\par
\fs28\tab\b Collider\b0\fs24\par
\par
\lang9\b\fs22 Collider Type\b0 : \lang1033 Defines Collider type for mesh fragments if they bounding box size is less than \b Size Filter \b0 value. Useful in case you want to apply simple colliders for a lot of small fragments. \fs24\par
\par
\lang9\b\fs22 Size Filter\b0 : \lang1033 Defines Bounding Box size value for Collider Type property. Turned Off if set to 0.\fs24\par
\par
\fs28\tab\b Mesh Ops\b0\fs24\par
\par
\lang9\b\fs22 Decompose\b0 : \lang1033 Decompose output fragment's mesh to several meshes if they are not connected with each other.\fs24\par
\par
\lang9\b\fs22 Remove Collinear\b0 : \lang1033 Remove collinear vertices on output fragment's mesh.\fs24\par
\par
\fs28\tab\b Custom Layer\b0\fs24\par
\par
\lang9\b\fs22 Layer\b0 : \lang1033 Set custom Layer to fragments.\fs24\par
\par
\fs28\tab\fs24\par
\i\fs36\tab Runtime Caching\i0\fs24\par
\lang9\b\fs32{\field{\*\fldinst{HYPERLINK "https://youtu.be/RF-srUHcy0g"}}{\fldrslt{\ul\cf1 https://youtu.be/RF-srUHcy0g}}}\lang1033\b0\f0\fs24\par
\par
\lang9\b\fs22 Type\b0 : \lang1033 Defines Runtime Caching type. Disabled by default.\fs24\par
\pard\nowidctlpar\li720\sl276\slmult1\tx720\f1\'b7\tab\b\f0\fs22 By Frames\b0 : Cache fragment's meshes over defined amount of frames.\fs24\par
\f1\'b7\tab\b\f0\fs22 By Fragments per Frame\b0 : Cache defined amount of fragment's meshes every frame.\fs24\par
\pard\nowidctlpar\li360\sl276\slmult1\par
\pard\nowidctlpar\sl276\slmult1\lang9\b\fs22 Frames\b0 : \lang1033 Defines amount of frames for \b By Frames \b0 type.\fs24\par
\par
\lang9\b\fs22 Fragments\b0 : \lang1033 Defines amount of fragments for \b By Fragments per Frame \b0 type.\fs24\par
\par
\lang9\b\fs22 Skip First Demolition\b0 : \lang1033 Do not demolish object when all meshes were cached and wait for next demolition. Allows to use first Demolition to initiate caching and demolish object only at second demolition.\fs24\par
\par
\par
\i\fs44\tab Cluster Demolition\i0\fs24\par
\lang9\b\fs32{\field{\*\fldinst{HYPERLINK "https://youtu.be/fNFG4SGWuQQ"}}{\fldrslt{\ul\cf1 https://youtu.be/fNFG4SGWuQQ}}}\lang1033\b0\f0\fs24\par
\b\fs32{\field{\*\fldinst{HYPERLINK "https://youtu.be/ZuHq1OFylnM"}}{\fldrslt{\ul\cf1 https://youtu.be/ZuHq1OFylnM}}}\b0\f0\fs24\par
\par
\fs28\tab\b Properties\b0\fs24\par
\par
\lang9\b\fs22 Connectivity\b0 : \lang1033 Define the the way connections among Shards will be calculated. \fs24\par
\f1\'b7\tab\b\f0\fs22 By Bounding Box\b0 : Shards will be considered as connected if their bound boxes interpenetrates with each other. This is the fastest way to establish connectivity and can be used in Runtime, but calculated shared are value will not be precise and will be based on shard's size.\fs24\par
\f1\'b7\tab\b\f0\fs22 By Mesh\b0 : Shards will be considered as connected if triangle of one Shard fits triangle of neighbor shard. This is the slowest way to establish connectivity and should be used only in Editor with Setup Cluster button, but it precisely calculates shared area value which provides realistic Collapse By Area.\fs24\par
\f1\'b7\tab\b\f0\fs22 By Bounding Box and Mesh\b0 : Shards will be considered as connected if their bound boxes interpenetrates with each other. If Shards also share triangles then Shared area will be calculated using By Mesh method, if shards do not share triangles then By Bounding Box method will be used.\fs24\par
\fs22\par
\tab\lang9\b\fs28 Filters\lang1033\b0\fs24\par
\fs22\par
Filters allows you to decrease amount of connections. There are three filters and they are turned off by default.\fs24\par
\par
\b\fs22 Minimum Area\b0 : Two shards will have connection if their shared area is bigger than this value.\fs24\par
\b\fs22 Minimum Size\b0 : Two shards will have connection if their size is bigger than this value.\fs24\par
\b\fs22 Percentage\b0 : Random percentage of connections will be discarded.\fs24\par
\b\fs22 Seed\b0 : Seed for random percentage filter and for Random Collapse.\fs24\par
\par
\b\fs28\tab Demolition Distance\par
\b0\fs22\par
When Connected Cluster collides with something or get Impact from Gun and should be demolished at contact point it has to decided how much Shards should be detached into separate fragments, all Shards in \b Demolition Distance \b0 radius from contact point will be detached. \par
Then the rest of the Shards will check for connectivity with each other and if there are several groups of Shards which connected only with each other then such groups will be simulated as separate Connected Clusters.\par
\lang9\b\par
Type\b0 : \lang1033 Defines the way Demolition Distance will be measured. \fs24\par
\f1\'b7\tab\b\f0\fs22 Ratio To Size\b0 : Measured in percentage relative to initial cluster size. \par
For instance, if cluster size is 50 units and Ratio To Size value is 20% then Demolition Distance radius will be 10 units and all Shards in 10 Units radius around contact point will be detached from cluster.\fs24\par
\f1\'b7\tab\b\f0\fs22 World Units\b0 : Measured in world Units.\fs24\par
\lang9\b\fs22\par
Ratio\b0 : \lang1033 Percentage value for Demolition Distnace.\par
\par
\lang9\b Units\b0 : \lang1033 World Units value for Demolition Distance.\lang9\b\par
\par
\lang1033\fs28\tab Shards\par
\b0\fs22\par
All detached Shards in Demolition Distance area will get RayFire Rigid Component with Mesh object type and will be simulated separately. All such Shards will inherit Mesh Demolition properties from initial Connected Cluster Rigid. But it is possible to clusterize these detached Shards into small Connected Clusters, thanks to this you can create smooth transition between Initial demolished Connected Cluster to separate detached SHards so between them there will be small groups of Connected Clusters. \lang9\b\par
\par
Shard Area\b0 : \lang1033 Defines percentage relative to Demolition Distance. \par
For instance, Cluster size is 50 units, Demolition Distance is 20 units, so all Shards in 20 units radius around contact point will be detached from demolished connected cluster. If Shard Area value is 100% then all Shards will be simulated separately as Rigid with Mesh object type, if Shards Area value is 25% then only Shards in 5 units radius around contact point will be simulated separately and the rest of the Shards from 5 to 20 units radius will be divided into groups and every group will be simulated as small Connected Cluster. Amount of such groups can be defined using Min and Max Amount properties in Cluster section.\fs24\par
\lang9\b\fs22\par
Shard Demolition\b0 : \lang1033 Set Runtime demolition type for detached Shards with Mesh object type.\fs24\par
\lang9\b\fs22\par
\lang1033\fs28\tab Clusters\lang9\fs22\par
\par
Min Amout\b0 : \lang1033 Defines minimum amount of Connected Clusters which will be created inside Demolition Distance radius.\par
\par
\lang9\b Max Amount\b0 : \lang1033 Defines maximum amount of Connected Clusters which will be created inside Demolition Distance radius. Final value will be picked randomly between Min and Max range.\par
\par
\lang9\b Demolishable\b0 : \lang1033 Set Runtime demolition type for created Connected Clusters so it will be possible to demolish them as well.\fs24\par
\fs22\par
\par
\b\fs28\tab Collapse\lang9\fs22\par
\par
Type\b0 : \lang1033 There are three ways to break connections among Shards. You should try in Editor all of them to find the one which looks better for your structure and your goal.  \fs24\par
\f1\'b7\tab\b\f0\fs22 By Area\b0 : Shard will loose it's connections if it's shared area surface is less then defined value.\fs24\par
\f1\'b7\tab\b\f0\fs22 By Size\b0 : Shard will loose it's connections if it's Size is less then defined value.\fs24\par
\f1\'b7\tab\b\f0\fs22 Random\b0 : Shard will loose it's connections if it's random value in range from 0 to 100 is less then defined value.\fs24\par
\par
\b\fs22 Start\b0 : Defines start value in percentage relative to whole range of picked type. For instance, Type set to By Size, you have 200 shards with the smallest shard size equal to 0.1 unit and biggest shard size equal to 50 units. If you set \b Start \b0 value to 50% it will start collapse by setting By Size threshold value to 25 units and all shards with size less than 25 units will loose their connections. Increase this value if you want to Start Collapse quickly so a lot of shards will loose connections and will be activated right from the beginning. Set it to 0 if you want to start collapse slowly activating shards one by one.\fs24\par
\par
\b\fs22 End\b0 : Defines end value in percentage relative to whole range of picked type. Set tp 100 if you want to break all connections or set it lower if you want to keep some connections.\fs24\par
\par
\b\fs22 Steps\b0 : Amount of times when defined threshold value will be set during \b Duration \b0 period. \fs24\par
\par
\b\fs22 Duration\b0 : Time which it will take \b Start \b0 value to be increased to \b End \b0 value\lang9\b .\lang1033\b0\fs24\par
\par
\i\fs44\tab Reference Demolition\par
\i0\fs22 Using Reference Demolition type you can swap demolished object to another Gameobject in scene, Prefab asset, FBX asset or even custom Particle System with your own scripts. This demolition type can be used for fragments which you just created using Shatter component or for FBX asset with fragments which you imported from another 3d package.\par
If Reference is just one object than at demolition it will be demolished instead of original object. \par
If Reference is empty root with children then these children will be simulated as fragments.\par
It is also possible to keep Reference field empty so original demolished object will disappear without leaving anything instead. \par
\fs24\par
\b\fs32{\field{\*\fldinst{HYPERLINK "https://youtu.be/CtY4w16357Q"}}{\fldrslt{\ul\cf1 https://youtu.be/CtY4w16357Q}}}\b0\f0\fs24\par
\par
\par
\fs28\tab\b Source\b0\fs24\par
\par
\lang9\b\fs22 Reference\b0 : \lang1033 Defines reference for demolition. Reference will be instantiated and demolished instead of original object.\fs24\par
\par
\lang9\b\fs22 Random List\b0 : \lang1033 Allows to define several references and pick for demolition one random.\fs24\par
\par
\fs28\tab\b Properties\b0\fs24\par
\par
\lang9\b\fs22 Add Rigid\b0 : \lang1033 All references without Rigid Component will get it automatically. Single Object will get Mesh Object Type, Roots with group of mesh objects will get Mesh Root object type.\fs24\par
\par
\lang9\b\fs22 Inherit Scale\b0 : \lang1033 Instantiated reference will inherit original object scale.\fs24\par
\par
\lang9\i\fs44\tab Materials\lang1033\i0\fs24\par
\lang9\b\fs32{\field{\*\fldinst{HYPERLINK "https://youtu.be/2Aqdzt58xw0"}}{\fldrslt{\ul\cf1 https://youtu.be/2Aqdzt58xw0}}}\lang1033\b0\f0\fs24\par
\par
\b\fs28\tab Inner surface\b0\fs24\par
\par
\lang9\b\fs22 Inner material\b0 : \lang1033 Defines material for fragment's inner surface. If not applied RayFire will use original object material for inner surface.\fs24\par
\par
\lang9\b\fs22 Mapping Scale\b0 : \lang1033 Defines mapping scale for inner surface. Using this property you can increase or decrease size of texture for inner surface.\fs24\par
\b\fs28\tab\b0\fs24\par
\b\fs28\tab Outer surface\b0\fs24\par
\par
\lang9\b\fs22 Outer material\b0 : \lang1033 Defines material for fragment's.\fs24\par
\par
\lang9\i\fs44\tab Damage\lang1033\i0\fs24\par
\lang9\b\fs32{\field{\*\fldinst{HYPERLINK "https://youtu.be/WfoaziBQiGU"}}{\fldrslt{\ul\cf1 https://youtu.be/WfoaziBQiGU}}}\lang1033\b0\f0\fs24\par
\par
\lang9\b\fs22 Enable\b0 : \lang1033 Allows to demolish object by it's own floating Damage value. Object will be demolished when Current Damage value will be more or equal Max Damage value. Current Damage value can be increased by RayFireBomb and RayFireGun components, by Collision or by public method:\fs24\par
\par
\i\f3\fs20\tab\cf1\lang1049\i0\f2\fs19 public\cf2  \cf1 bool\cf2  ApplyDamage(\cf1 float\cf2  damageValue, Vector3 damagePosition)\cf0\lang1033\f0\fs24\par
\par
\cf2\i\fs22 d\lang1049\f4 amagePosition\lang1033\f0 : P\i0 osition in world space. In this case damage position will be used by Contact Bias to create more tiny fragments at damaged area. \cf0\fs24\par
\cf2\fs22 True boolean return value means than object was demolished because of applied damage.\cf0\fs24\par
\par
\lang9\b\fs22 Max Damage\b0 : \lang1033 Defines maximum allowed damage for object before it will be demolished.\fs24\par
\par
\lang9\b\fs22 Current Damage\b0 : \lang1033 Shows current damage value.\fs24\par
\par
\lang9\b\fs28\tab Collisions\lang1033\b0\fs24\par
\par
\lang9\b\fs22 Collect \b0 : \lang1033 Allows to accumulate damage value by collisions during dynamic simulation.\fs24\par
\par
\b\fs22 Multiplier\b0 : Multiply collected collision damage.\fs24\par
\lang9\b\fs32\tab\lang1033\b0\fs24\par
\lang9\i\fs44\tab Fading\lang1033\i0\fs24\par
\lang9\b\fs32{\field{\*\fldinst{HYPERLINK "https://youtu.be/wYFPii-pAuY"}}{\fldrslt{\ul\cf1 https://youtu.be/wYFPii-pAuY}}}\lang1033\b0\f0\fs24\par
\par
\par
\lang9\b\fs22 Fade Type\b0 : Fading let you keep your scene clean and optimize dynamic simulation by destroying fragments  or excluding  them from simulation. \lang1033\fs24\par
\pard\nowidctlpar\li720\sl276\slmult1\tx720\f1\'b7\tab\b\f0\fs22 None\b0 : Fragments will stay in scene with no limitation and they always will be simulated.\fs24\par
\f1\'b7\tab\b\f0\fs22 Sim Exclude\b0 : Fragments will be simulated for\b  Life Time \b0 period after their birth, then  their Colliders and RigidBody components will be destroyed. \fs24\par
\f1\'b7\tab\b\f0\fs22 Move Down\b0 : Fragments will be simulated for \b Life Time \b0 period after their birth, then they will fall through the ground and will be destroyed after \b Fade Time \b0 period. \fs24\par
\f1\'b7\tab\b\f0\fs22 Scale Down\b0 : Fragments will be simulated for \b Life Time \b0 period after their birth, then they will start slowly scaling to nothing during \b Fade Time \b0 period and destroyed after all.\fs24\par
\f1\'b7\tab\b\f0\fs22 Destroy: \b0 Fragments will be simulated for \b Life Time \b0 period after their birth and destroyed instantly.\fs24\par
\pard\nowidctlpar\sl276\slmult1\par
\lang9\b\fs22 Size FIlter\b0 : Prevent object for fading if it's size bigger than defined value\lang1033 . Turned Off if 0.\fs24\par
\par
\lang9\b\fs22 Life Time\b0 : Minimum  p\lang1033 eriod of time in seconds during which fragments created by demolition or slicing will be simulated.\fs24\par
\par
\lang9\b\fs22 Life Variation\b0 : \lang1033 Add random period of time in seconds to final \b Life Time.\b0\fs24\par
\par
\lang9\b\fs22 Fade Time\b0 : \lang1033 Period of time in seconds during which object slowly moves through the ground or scales down to nothing.\fs24\par
\par
\lang9\i\fs44\tab Reset WIP\lang1033\i0\fs24\par
\lang9\b\fs32{\field{\*\fldinst{HYPERLINK "https://www.youtube.com/watch?v=6h94gd_gDrY"}}{\fldrslt{\ul\cf1 https://www.youtube.com/watch?v=6h94gd_gDrY}}}\lang1033\b0\f0\fs24\par
\par
\lang9\i\fs44\tab\lang1033\i0\fs24\par
\lang9\i\fs44\tab Events\lang1033\i0\fs24\par
\lang9\b\fs32{\field{\*\fldinst{HYPERLINK "https://youtu.be/lRlqcHGA1sI"}}{\fldrslt{\ul\cf1 https://youtu.be/lRlqcHGA1sI}}}\lang1033\b0\f0\fs24\par
\par
\fs22 RayFire Rigid component provides subscription to \b Demolition \b0 and \b Activation \b0 events.\fs24\par
\pard\box\brdrs\brdrw0\brdrcf2 \nowidctlpar\sl276\slmult1\par
\fs22 Subscription to \b Global \b0 event will invoke subscribed method when any demolition happens.\fs24\par
\par
\b\fs22 Global Demolition \b0 event subscription reference\b : \cf3\b0\f3\fs18  \cf0\f0\fs24\par
\b\f3\fs18\tab\lang1049\b0\f2 RFDemolitionEvent.GlobalEvent += \lang1033\f3 MyMethod\lang1049\f2 ;\lang1033\f0\fs24\par
\par
\b\fs22 Global Activation \b0 event subscription reference\b : \cf3\b0\f3\fs18  \cf0\f0\fs24\par
\b\f3\fs18\tab\lang1049\b0\f2 RF\lang1033\f3 Activation\lang1049\f2 Event.GlobalEvent += \lang1033\f3 MyMethod\lang1049\f2 ;\lang1033\f0\fs24\par
\pard\nowidctlpar\sl276\slmult1\par
\pard\box\brdrs\brdrw0\brdrcf2 \nowidctlpar\sl276\slmult1\fs22 Subscription to \b Local \b0 event will invoke subscribed method when demolition of specific Rigid script happens and because of this you need to have reference to Rigid component you want to track. \fs24\par
\par
\b\fs22 Local Demolition \b0 event subscription reference\b : \cf3\b0\f3\fs18  \cf0\f0\fs24\par
\cf3\f3\fs18\tab\cf0\lang1049\f2 GameObject \lang1033\f3 myGameObject\lang1049\f2  = GameObject.Find("\lang1033\f3 MyObjectWithRigidComponent\lang1049\f2 ");\lang1033\f0\fs24\par
\f3\fs18\tab\lang1049\f2 RayfireRigid rigid = \lang1033\f3 myGameObject\lang1049\f2 .\b GetComponent\b0 <RayfireRigid>();\line\lang1033\f3\tab\lang1049\f2 rigid.demolitionEvent.LocalEvent \lang1033\f3 +\lang1049\f2 = \lang1033\f3 MyMethod\lang1049\f2 ;\lang1033\f0\fs24\par
\par
\b\fs22 Local Activation \b0 event subscription reference\b : \cf3\b0\f3\fs18  \cf0\f0\fs24\par
\cf3\f3\fs18\tab\cf0\lang1049\f2 GameObject \lang1033\f3 myGameObject\lang1049\f2  = GameObject.Find("\lang1033\f3 MyObjectWithRigidComponent\lang1049\f2 ");\lang1033\f0\fs24\par
\f3\fs18\tab\lang1049\f2 RayfireRigid rigid = \lang1033\f3 myGameObject\lang1049\f2 .\b GetComponent\b0 <RayfireRigid>();\line\lang1033\f3\tab\lang1049\f2 rigid.\lang1033\f3 activation\lang1049\f2 Event.LocalEvent \lang1033\f3 +\lang1049\f2 = \lang1033\f3 MyMethod\lang1049\f2 ;\lang1033\f0\fs24\par
\pard\nowidctlpar\sl276\slmult1\par
\pard\box\brdrs\brdrw0\brdrcf2 \nowidctlpar\sl276\slmult1\fs22 Keep in mind that \f3\fs18 MyMethod\f0\fs22  should have RayFireRigid component as input, in this way you can get access to all public variables of Rigid component, for instance:\fs24\par
\pard\box\brdrs\brdrw0\brdrcf2 \nowidctlpar\li720\sl276\slmult1\lang1049\f2\fs18 void \lang1033\f3 MyMethod\lang1049\f2 (RayfireRigid rigid)\line\b\{\line     \b0 Debug.Log(rigid.\i fragments\i0 .\i Count\i0 );\line\}\lang1033\f0\fs24\par
\pard\box\brdrs\brdrw0\brdrcf2 \nowidctlpar\sl276\slmult1\fs22 will show in console amount of fragments which were created as a result of demolition.\fs24\par
\pard\nowidctlpar\sl276\slmult1\par
}
 